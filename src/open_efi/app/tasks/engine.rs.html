<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/app/tasks/engine.rs`."><title>engine.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-f40c346f39d9abc1.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="open_efi" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (22e9fe644 2023-06-23)" data-channel="nightly" data-search-js="search-95c92dd01058facf.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../../static.files/source-script-11255107d0a65077.js"></script><script defer src="../../../../source-files.js"></script><script defer src="../../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../../../open_efi/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
</pre></div><pre class="rust"><code><span class="comment">// use fugit::Duration;
</span><span class="kw">use </span>rtic::Mutex;
<span class="kw">use </span>rtic::mutex_prelude::TupleExt04;
<span class="kw">use </span>stm32f4xx_hal::gpio::ExtiPin;
<span class="kw">use </span>rtic_monotonics::systick::<span class="kw-2">*</span>;
<span class="kw">use crate</span>::{
    app,
};
<span class="kw">use </span><span class="kw">crate</span>::app::engine::cpwm::{angle_to_time, get_crank_angle};

<span class="kw">use </span><span class="kw">crate</span>::app::engine::efi_cfg::VRSensor;

<span class="comment">// from: https://github.com/noisymime/speeduino/blob/master/speeduino/decoders.ino#L453
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>ckp_trigger(<span class="kw-2">mut </span>ctx: app::ckp_trigger::Context) {
    <span class="kw">let </span><span class="kw-2">mut </span>efi_cfg = ctx.shared.efi_cfg;
    <span class="kw">let </span><span class="kw-2">mut </span>efi_status = ctx.shared.efi_status;

    <span class="kw">let </span><span class="kw-2">mut </span>ckp_status = ctx.shared.ckp;

    <span class="kw">let </span><span class="kw-2">mut </span>ckp = VRSensor::new();
    <span class="kw">let </span><span class="kw-2">mut </span>rpm = <span class="number">0</span>;

    <span class="comment">// lock previo y libero los recursos que no se vuelven a usar para otra cosa aca adentro
    </span>efi_cfg.lock(|cfg| { ckp = cfg.engine.ckp });
    efi_status.lock(|status| { rpm = status.rpm });

    ckp_status.lock(|ckp_status| {
        ctx.shared.timer4.lock(|t4| { ckp_status.current_time = t4.now().ticks(); });
        ckp_status.current_gap = ckp_status.current_time - ckp_status.tooth_last_time;

        <span class="kw">if </span>ckp_status.current_gap &gt;= ckp.trigger_filter_time {
            ckp_status.tooth_current_count += <span class="number">1</span>;


            <span class="kw">if </span>ckp_status.tooth_last_time &gt; <span class="number">0 </span>&amp;&amp; ckp_status.tooth_last_minus_one_tooth_time &gt; <span class="number">0 </span>{
                ckp_status.is_missing_tooth = <span class="bool-val">false</span>;

                <span class="comment">/*
                  Performance Optimisation:
                  Only need to try and detect the missing tooth if:
                  1. WE don&#39;t have sync yet
                  2. We have sync and are in the final 1/4 of the wheel (Missing tooth will/should never occur in the first 3/4)
                  3. RPM is under 2000. This is to ensure that we don&#39;t interfere with strange timing when cranking or idling. Optimisation not really required at these speeds anyway
                */
                </span><span class="kw">if </span>ckp_status.has_sync == <span class="bool-val">false </span>|| rpm &lt; <span class="number">2000 </span>|| ckp_status.tooth_current_count &gt;= (<span class="number">3 </span>* ckp.trigger_actual_teeth &gt;&gt; <span class="number">2</span>) {
                    <span class="comment">//Begin the missing tooth detection
                    //If the time between the current tooth and the last is greater than 1.5x the time between the last tooth and the tooth before that, we make the assertion that we must be at the first tooth after the gap
                    </span><span class="kw">if </span>ckp.missing_tooth == <span class="number">1 </span>{
                        <span class="comment">//Multiply by 1.5 (Checks for a gap 1.5x greater than the last one) (Uses bitshift to multiply by 3 then divide by 2. Much faster than multiplying by 1.5)
                        </span>ckp_status.target_gap = (<span class="number">3 </span>* (ckp_status.tooth_last_time - ckp_status.tooth_last_minus_one_tooth_time)) &gt;&gt; <span class="number">1</span>;
                    } <span class="kw">else </span>{
                        <span class="comment">//Multiply by 2 (Checks for a gap 2x greater than the last one)
                        </span>ckp_status.target_gap = (ckp_status.tooth_last_time - ckp_status.tooth_last_minus_one_tooth_time) * ckp.missing_tooth;
                    }

                    <span class="comment">// initial startup, missing one time
                    </span><span class="kw">if </span>ckp_status.tooth_last_time == <span class="number">0 </span>|| ckp_status.tooth_last_minus_one_tooth_time == <span class="number">0 </span>{
                        ckp_status.target_gap = <span class="number">0</span>;
                    }

                    <span class="kw">if </span>(ckp_status.current_gap &gt; ckp_status.target_gap) || (ckp_status.tooth_current_count &gt; ckp.trigger_actual_teeth) {
                        <span class="comment">//Missing tooth detected
                        </span>ckp_status.is_missing_tooth = <span class="bool-val">true</span>;

                        <span class="kw">if </span>ckp_status.tooth_current_count &lt; ckp.trigger_actual_teeth {
                            <span class="comment">// This occurs when we&#39;re at tooth #1, but haven&#39;t seen all the other teeth. This indicates a signal issue so we flag lost sync so this will attempt to resync on the next revolution.
                            </span>ckp_status.has_sync = <span class="bool-val">false</span>;
                            ckp_status.sync_loss_counter += <span class="number">1</span>;
                        }
                        <span class="comment">//This is to handle a special case on startup where sync can be obtained and the system immediately thinks the revs have jumped:
                        </span><span class="kw">else </span>{
                            <span class="kw">if </span>ckp_status.has_sync {
                                ctx.shared.led.lock(|l| { l.led_check.toggle() });
                                ckp_status.start_revolution += <span class="number">1</span>;
                            } <span class="kw">else </span>{
                                ckp_status.start_revolution = <span class="number">0</span>;
                                ctx.shared.led.lock(|l| { l.led_mil.toggle() });
                            }

                            ckp_status.tooth_current_count = <span class="number">1</span>;

                            <span class="comment">// tiempo entre vuelta completa
                            </span>ckp_status.tooth_one_minus_one_time = ckp_status.tooth_one_time;
                            ckp_status.tooth_one_time = ckp_status.current_time;

                            <span class="comment">// TODO: hay mas checks aca cuando es con inyección secuencial
                            </span>ckp_status.has_sync = <span class="bool-val">true</span>;
                            <span class="comment">//This is used to prevent a condition where serious intermittent signals (Eg someone furiously plugging the sensor wire in and out) can leave the filter in an unrecoverable state
                            </span>efi_cfg.lock(|ec| { ec.engine.ckp.trigger_filter_time = <span class="number">0</span>; });
                            ckp_status.tooth_last_minus_one_tooth_time = ckp_status.tooth_last_time;
                            ckp_status.tooth_last_time = ckp_status.current_time;
                            <span class="comment">// ctx.shared.ckp_tooth_last_time.lock(|ckp_t| { *ckp_t = ckp_status.current_time });
                        </span>}
                    }
                }

                <span class="kw">if </span>!ckp_status.is_missing_tooth {
                    efi_cfg.lock(|ec| { ec.engine.ckp.trigger_filter_time = ckp_status.current_gap &gt;&gt; <span class="number">2</span>; });
                    ckp_status.tooth_last_minus_one_tooth_time = <span class="number">0</span>;
                }
            } <span class="kw">else </span>{
                <span class="comment">// initial startup
                </span>ckp_status.tooth_last_minus_one_tooth_time = ckp_status.tooth_last_time;
                ckp_status.tooth_last_time = ckp_status.current_time;
                <span class="comment">//  ctx.shared.ckp_tooth_last_time.lock(|ckp_t| { *ckp_t = ckp_status.current_time });
            </span>}
        }
    });
    <span class="comment">// Obtain access to the peripheral and Clear Interrupt Pending Flag
    </span>ctx.local.ckp.clear_interrupt_pending_bit();
}

<span class="comment">// TODO: add similar stall control of speeduino
// https://github.com/noisymime/speeduino/blob/master/speeduino/speeduino.ino#L146
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">async fn </span>ckp_checks(<span class="kw-2">mut </span>ctx:  app::ckp_checks::Context&lt;<span class="lifetime">&#39;_</span>&gt;) {
    <span class="kw">let </span><span class="kw-2">mut </span>efi_cfg = ctx.shared.efi_cfg;
    <span class="kw">let </span><span class="kw-2">mut </span>ckp = ctx.shared.ckp;
    <span class="kw">let </span><span class="kw-2">mut </span>efi_status = ctx.shared.efi_status;
    <span class="kw">let </span><span class="kw-2">mut </span>cycle_time = <span class="number">0</span>;

    <span class="kw">let </span><span class="kw-2">mut </span>ignition_running = ctx.shared.ignition_running;

    ctx.shared.timer4.lock(|t4| { cycle_time = t4.now().ticks(); });

    (efi_cfg, ckp, efi_status,ignition_running).lock(|cfg, ckp, efi_status,ignition_running| {
        <span class="comment">//ste hijodeputa fue por lo que se tosto la bobina
        </span><span class="kw">if  </span>ckp.tooth_last_time &gt; cycle_time || cycle_time - ckp.tooth_last_time &lt; <span class="number">366_667 </span><span class="comment">/* 50RPM */  </span>{
            <span class="comment">// RPM &amp; no stall
            // en speeduino revisan &quot;BIT_DECODER_TOOTH_ANG_CORRECT&quot; aca, por ahora no lo agregue al trigger
            // tambien utilizan rpmDOT para ver la variacion cada 100mS, falta implementar
            // TODO: mover a fun aparte

            </span><span class="kw">let </span><span class="kw-2">mut </span>time_per_degreex16;

            <span class="comment">// esto calcula el tiempo por grado desde el tiempo entre los ultimos 2 dientes
            </span><span class="kw">if </span><span class="bool-val">true </span><span class="comment">/* BIT_DECODER_TOOTH_ANG_CORRECT*/ </span>&amp;&amp; (ckp.tooth_last_time &gt; ckp.tooth_last_minus_one_tooth_time) &amp;&amp; <span class="number">20</span><span class="comment">/*(abs(currentStatus.rpmDOT)*/ </span>&gt; <span class="number">30 </span>{
                time_per_degreex16 = ((ckp.tooth_last_time - ckp.tooth_last_minus_one_tooth_time) * <span class="number">16</span>) / cfg.engine.ckp.trigger_tooth_angle <span class="kw">as </span>u32;
                <span class="comment">// timePerDegree = time_per_degreex16 / 16;
            </span>} <span class="kw">else </span>{
                <span class="comment">//Take into account any likely acceleration that has occurred since the last full revolution completed:
                //long rpm_adjust = (timeThisRevolution * (long)currentStatus.rpmDOT) / 1000000;
                </span><span class="kw">let </span>rpm_adjust = <span class="number">0</span>;
                time_per_degreex16 = (<span class="number">2_666_656 </span>/ efi_status.rpm + rpm_adjust) <span class="kw">as </span>u32; <span class="comment">//The use of a x16 value gives accuracy down to 0.1 of a degree and can provide noticeably better timing results on low resolution triggers
                // timePerDegree = time_per_degreex16 / 16;
            </span>}

            <span class="comment">// ckp.degreesPeruSx2048 = 2048 / timePerDegree;
            </span>ckp.degreesPeruSx32768 = (<span class="number">524288 </span>/ time_per_degreex16) <span class="kw">as </span>f32;

            <span class="comment">// ignition timing:
            </span><span class="kw">let </span><span class="kw-2">mut </span>crank_angle = get_crank_angle(ckp, <span class="kw-2">&amp;</span>cfg.engine.ckp, cycle_time);
            <span class="kw">const </span>CRANK_ANGLE_MAX_IGN: i32 = <span class="number">720</span>; <span class="comment">//ponele? no entendi bien como se setea dependiendo el tipo de encendido/cilindros
            </span><span class="kw">while </span>crank_angle &gt; CRANK_ANGLE_MAX_IGN { crank_angle -= CRANK_ANGLE_MAX_IGN; } <span class="comment">// SDUBTUD: no entendi para que es esto pero quien soy para cuestionar a speeduino

            </span><span class="kw">let </span>dwell_angle = <span class="number">20</span>; <span class="comment">//TODO: get from table
            </span><span class="kw">let </span>dwell_time = angle_to_time(ckp,<span class="kw-2">&amp;</span>dwell_angle);

            <span class="comment">// tiene que ser task externa
            // if !*ignition_running /* &amp;&amp; get_cranking_rpm(ckp, &amp;cfg.engine.ckp) != 0*/{
            //     *ignition_running = true;
            //     //seteamos nuevo triggerrr
            //     // let dwell_ticks = (120_000_000 / 100_000) * dwell_time as u64;
            //     // let dwell_duration = Duration::&lt;u64, 1, 100_000&gt;::from_ticks(dwell_ticks);
            //     // SDUBTUD: si esto anda es de puro milagro
            //     // app::ignition_trigger::spawn_after(dwell_duration).unwrap();
            // }

            // esto se usa para iny
            </span>get_crank_angle(ckp, <span class="kw-2">&amp;</span>cfg.engine.ckp, cycle_time);
        } <span class="kw">else </span>{
            ckp.reset();
        }
        cfg.engine.ckp.max_stall_time;
    });

    Systick::delay(<span class="number">100</span>.micros()).<span class="kw">await</span>;
}</code></pre></div></section></main></body></html>